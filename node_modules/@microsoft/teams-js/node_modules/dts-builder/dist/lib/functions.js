"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var fs = require("fs");
var mkdirp = require("mkdirp");
var log_1 = require("./log");
var copy_file_1 = require("./copy-file");
var find_files_1 = require("./find-files");
var patterns = require("./regexp-patterns");
function generateSingleBundle(bundle) {
    return new Promise(function (resolve, reject) {
        log_1.log("> Generating bundle %s", bundle.name);
        if (!bundle.sourceDir) {
            reject("No sourceDir was specified for bundle " + bundle.name);
            return;
        }
        log_1.log(" + Gathering definitions from %s/**/*.d.ts", bundle.sourceDir);
        find_files_1.findFiles(bundle.sourceDir)
            .then(filesToString)
            .then(function (txtBuffer) {
            log_1.log("   + Total size: %d characters", txtBuffer.length);
            log_1.log(" + Optimizing imports...");
            txtBuffer = optimizeImports(txtBuffer);
            if (bundle.wrap === undefined || bundle.wrap === true) {
                log_1.log(" + Wrapping with module...");
                txtBuffer = moduleWrap(txtBuffer, bundle);
            }
            log_1.log(" + Removing empty lines...");
            txtBuffer = cleanEmptyLines(txtBuffer);
            if (bundle.externals) {
                log_1.log(" + Adding external definition files...");
                txtBuffer = addExternalRefs(bundle) + "\n" + txtBuffer;
            }
            if (!fs.existsSync(bundle.destDir)) {
                mkdirp(bundle.destDir, function (err) {
                    if (err) {
                        reject("Unable to generate bundle " + bundle.name + ": " + err);
                    }
                    else {
                        log_1.log(" + Created destrination directory: %s", bundle.destDir);
                        writeResult(bundle, txtBuffer)
                            .then(function () { return resolve(bundle.name); });
                    }
                });
            }
            else {
                writeResult(bundle, txtBuffer)
                    .then(function () { return resolve(bundle.name); });
            }
        })
            .catch(function (reason) {
            reject("Failed generating bundle \"" + bundle.name + "\": " + reason);
        });
    });
}
exports.generateSingleBundle = generateSingleBundle;
/*******************************************
 *** Internal
 *******************************************/
function filesToString(files) {
    if (!Array.isArray(files) || !files.length) {
        log_1.log("No definition files were found for bundle");
        return Promise.reject("No defnition files");
    }
    return new Promise(function (resolve, reject) {
        log_1.log("   + Found %d definition files.", files.length);
        log_1.log(" + Concatenating definitions to a single file");
        resolve(files
            .map(function (file) { return fs.readFileSync(file); })
            .map(function (buffer) { return buffer.toString(); })
            .join("\n"));
    });
}
function optimizeImports(txtBuffer) {
    // remove imports
    var result = txtBuffer.replace(patterns.externalModule, "");
    // get unique internal imports
    var matches = result.match(patterns.internalModule);
    var internalImports = matches ? getUnique(matches.map(function (imp) { return imp.toString().trim(); })) : [];
    // remove internal imports
    result = result.replace(patterns.internalModule, "");
    // remove internal inline imports
    result = result.replace(patterns.internalInlineModule, "");
    var remaining = result.match(/\bimport\b/);
    if (remaining && remaining.length) {
        throw new Error("optimizeImports() could not deal with the following: " + JSON.stringify(remaining, null, 2));
    }
    // add internals
    result = sortInternals(internalImports).join("\n") + "\n" + result;
    result = removeReferences(result);
    result = removeDefaults(result);
    // remove export * from ...
    result = result.replace(patterns.externalReExports, "");
    // remove export declarations
    result = result.replace(patterns.exportDeclarations, "");
    return result;
}
function moduleWrap(text, bundle) {
    log_1.log(" * Converting to module...");
    var camelName = toCamel(bundle.name);
    var lines = text
        .split("\n")
        .map(function (line) { return "  " + line
        .replace(/\bexport\s+declare\s+/, "export ")
        .replace(/\bdeclare\s+(class|function|const|var|let)\s+/, "$1 "); });
    lines.unshift("\ndeclare module '" + camelName + "' {\n  export = " + camelName + ";\n}\n\ndeclare namespace " + camelName + " {");
    lines.push("}");
    // add alias
    if (bundle.alias) {
        lines.unshift("import " + bundle.alias + " = " + camelName + ";");
    }
    return lines.join("\n");
}
/**
 * Remove empty lines, when 2 or more in a sequence
 */
function cleanEmptyLines(text) {
    var prevEmpty = false;
    return text.split("\n").filter(function (line) {
        var isEmpty = !line.trim().length;
        var keep = !isEmpty || !prevEmpty;
        prevEmpty = isEmpty;
        return keep;
    }).join("\n");
}
function addExternalRefs(bundle) {
    if (!bundle || !bundle.externals)
        return "";
    var res = bundle.externals.map(function (ref) {
        var fileName = path.basename(ref);
        copy_file_1.copyFile(ref, pathAppend(bundle.destDir, fileName), function (err, res) {
            if (err) {
                throw new Error(err.message);
            }
            // TODO: localize references of the copied file, or update path
            log_1.log("+++ Copied external reference: %s", path.basename(res));
        });
        log_1.log(" * Referencing external: %s", fileName);
        return "/// <reference path=\"" + fileName + "\" />";
    });
    return res.join("\n");
}
function writeResult(bundle, buffer) {
    return new Promise(function (resolve, reject) {
        var destFile = pathAppend(bundle.destDir, toKebab(bundle.name) + ".d.ts");
        log_1.log(" +-> Saving %s...", destFile);
        fs.writeFile(destFile, buffer, function (err) {
            if (err) {
                throw new Error(err.message);
            }
            log_1.log('! "%s" bundle is ready', bundle.name);
            resolve();
        });
    });
}
function toKebab(name) {
    if (!name)
        return "";
    return name.split(/\W+/).map(function (part) { return part.toLowerCase(); }).join("-");
}
function toCamel(name) {
    if (!name)
        return "";
    var parts = name.split(/\W+/);
    // if a single word, keep as is and don't camelize
    if (parts.length === 1)
        return name;
    // convert parts to camelCase
    parts[0] = parts[0].toLowerCase();
    for (var i = 1; i < parts.length; i++) {
        parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].substr(1).toLowerCase();
    }
    return parts.join("");
}
function pathAppend(src, dst) {
    src = src.trim().replace(/\/+$/, "");
    dst = dst.trim().replace(/^\/+/, "");
    return [src, dst].join("/");
}
/**
 * Returns unique array elements
 */
function getUnique(arr) {
    var res = [];
    arr.forEach(function (item) {
        if (res.indexOf(item) === -1)
            res.push(item);
    });
    return res;
}
function sortInternals(arr) {
    return arr
        .map(function (line) { return line.match(patterns.internalModuleParts); })
        .sort(sortMatches)
        .map(function (obj) { return obj && "import " + obj[1] + " = " + obj[2] + ";" || ""; });
}
function sortMatches(a, b) {
    var impA = a[2].toLowerCase();
    var impB = b[2].toLowerCase();
    if (impA < impB)
        return -1;
    if (impA > impB)
        return +1;
    return 0;
}
function removeReferences(text) {
    return text.replace(patterns.reference, "");
}
function removeDefaults(text) {
    return text
        .replace(patterns.defaultExport, "")
        .replace(patterns.defaultsFromNs, "");
}
//# sourceMappingURL=functions.js.map